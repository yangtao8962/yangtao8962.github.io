(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{454:function(v,_,a){"use strict";a.r(_);var t=a(56),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"什么是mq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是mq"}},[v._v("#")]),v._v(" 什么是MQ")]),v._v(" "),a("p",[v._v("​\t\tMQ(message queue)，从字面意思上看，"),a("code",[v._v("本质是个队列")]),v._v("，"),a("code",[v._v("FIFO 先入先出")]),v._v("，只不过队列中存放的内容是 message 而已，还是一种"),a("code",[v._v("跨进程的通信机制")]),v._v("，用于上下游传递消息。")]),v._v(" "),a("p",[v._v("​\t\t在互联网架构中，MQ 是一种非常常见的上下游“"),a("code",[v._v("逻辑解耦+物理解耦")]),v._v("”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。")]),v._v(" "),a("h2",{attrs:{id:"mq的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mq的作用"}},[v._v("#")]),v._v(" MQ的作用")]),v._v(" "),a("h3",{attrs:{id:"流量削峰"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流量削峰"}},[v._v("#")]),v._v(" 流量削峰")]),v._v(" "),a("p",[v._v("​\t\t如订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。"),a("code",[v._v("使用消息队列做缓冲")]),v._v("，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。")]),v._v(" "),a("h3",{attrs:{id:"应用解耦"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用解耦"}},[v._v("#")]),v._v(" 应用解耦")]),v._v(" "),a("p",[v._v("​\t\t应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统"),a("code",[v._v("要处理的内存被缓存在消息队列中")]),v._v("，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。")]),v._v(" "),a("h3",{attrs:{id:"异步处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步处理"}},[v._v("#")]),v._v(" 异步处理")]),v._v(" "),a("p",[v._v("​\t\t有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。")]),v._v(" "),a("h2",{attrs:{id:"mq的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mq的分类"}},[v._v("#")]),v._v(" MQ的分类")]),v._v(" "),a("h3",{attrs:{id:"activemq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#activemq"}},[v._v("#")]),v._v(" ActiveMQ")]),v._v(" "),a("p",[a("strong",[v._v("优点")])]),v._v(" "),a("ul",[a("li",[v._v("单机吞吐量万级")]),v._v(" "),a("li",[v._v("时效性 ms 级")]),v._v(" "),a("li",[v._v("可用性高，基于主从架构实现高可用性")]),v._v(" "),a("li",[v._v("较低的概率丢失数据")])]),v._v(" "),a("p",[a("strong",[v._v("缺点")])]),v._v(" "),a("ul",[a("li",[v._v("维护越来越少")]),v._v(" "),a("li",[v._v("高吞吐量场景较少使用")])]),v._v(" "),a("h3",{attrs:{id:"kafka"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[v._v("#")]),v._v(" Kafka")]),v._v(" "),a("p",[a("strong",[v._v("优点")])]),v._v(" "),a("ul",[a("li",[v._v("性能卓越，单机写入 TPS 约在百万条/秒，吞吐量高")]),v._v(" "),a("li",[v._v("时效性 ms 级")]),v._v(" "),a("li",[v._v("可用性非常高")]),v._v(" "),a("li",[v._v("分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用")]),v._v(" "),a("li",[v._v("消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次")]),v._v(" "),a("li",[v._v("有优秀的第三方 Kafka Web 管理界面 Kafka-Manager")]),v._v(" "),a("li",[v._v("在日志领域比较成熟，被多家公司和多个开源项目使用")]),v._v(" "),a("li",[v._v("功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用")])]),v._v(" "),a("p",[a("strong",[v._v("缺点")])]),v._v(" "),a("ul",[a("li",[v._v("Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象")]),v._v(" "),a("li",[v._v("队列越多，load 越高，发送消息响应时间变长")]),v._v(" "),a("li",[v._v("使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试")]),v._v(" "),a("li",[v._v("支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢")])]),v._v(" "),a("h3",{attrs:{id:"rocketmq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq"}},[v._v("#")]),v._v(" RocketMQ")]),v._v(" "),a("p",[a("strong",[v._v("优点")])]),v._v(" "),a("ul",[a("li",[v._v("单机吞吐量十万级，可用性非常高")]),v._v(" "),a("li",[v._v("分布式架构,消息可以做到 0 丢失")]),v._v(" "),a("li",[v._v("MQ 功能较为完善，扩展性好，支持 10 亿级别的消息堆积，不会因为堆积导致性能下降")]),v._v(" "),a("li",[v._v("java开发，可定制")])]),v._v(" "),a("p",[a("strong",[v._v("缺点")])]),v._v(" "),a("ul",[a("li",[v._v("支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟")]),v._v(" "),a("li",[v._v("社区活跃度一般,没有在 MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码")])]),v._v(" "),a("h3",{attrs:{id:"rabbitmq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[v._v("#")]),v._v(" RabbitMQ")]),v._v(" "),a("p",[a("strong",[v._v("优点")])]),v._v(" "),a("ul",[a("li",[v._v("由于 erlang 语言的高并发特性，性能较好")]),v._v(" "),a("li",[v._v("吞吐量到万级，MQ 功能比较完备")]),v._v(" "),a("li",[v._v("健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全")]),v._v(" "),a("li",[v._v("开源提供的管理界面非常棒，社区活跃度高，更新频率相当高")])]),v._v(" "),a("p",[a("strong",[v._v("缺点")])]),v._v(" "),a("ul",[a("li",[v._v("商业版需要收费，学习成本较高")])])])}),[],!1,null,null,null);_.default=r.exports}}]);